import 'dart:async';

import 'package:athena/core/constants/constants.dart';
import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

part 'auth_provider.g.dart'; // This will be generated by build_runner

// Renaming to AppAuth to avoid potential conflicts and make it specific to the app
@Riverpod(keepAlive: true)
class AppAuth extends _$AppAuth {
  late final StreamController<User?> _authStateController;
  StreamSubscription<AuthState>? _authSubscription;
  AuthChangeEvent? _lastAuthEvent; // Store the last event

  @override
  Stream<User?> build() {
    _authStateController = StreamController<User?>.broadcast();

    // Initialize with current user state
    _authStateController.add(supabaseClient.auth.currentUser);

    // Listen to Supabase auth state changes
    _authSubscription = supabaseClient.auth.onAuthStateChange.listen((data) {
      _authStateController.add(data.session?.user);
      _lastAuthEvent = data.event; // Capture the event
    });

    ref.onDispose(() {
      _authSubscription?.cancel();
      _authStateController.close();
    });

    return _authStateController.stream;
  }

  SupabaseClient get supabaseClient => Supabase.instance.client;
  User? get currentUser => supabaseClient.auth.currentUser;

  // Expose the auth state stream for GoRouter
  Stream<User?> get authStateChanges => _authStateController.stream;

  // Getter for the last auth event
  AuthChangeEvent? get lastAuthEvent => _lastAuthEvent;

  Future<void> signInWithPassword(String email, String password) async {
    try {
      await supabaseClient.auth.signInWithPassword(
        password: password,
        email: email,
      );
      // The stream will automatically update from onAuthStateChange
    } catch (e) {
      debugPrint('Error signing in: $e');
      rethrow;
    }
  }

  Future<void> signInWithOtp(String email) async {
    try {
      await supabaseClient.auth.signInWithOtp(
        email: email,
        emailRedirectTo:
            kIsWeb
                ? 'https://www.helloathena.app/auth/callback'
                : Constants.supabaseLoginCallbackUrlMobile,
      );
      // Note: This doesn't immediately update the auth state
      // The user will need to click the magic link sent to their email
    } catch (e) {
      debugPrint('Error signing in with OTP: $e');
      rethrow;
    }
  }

  // Future<void> _nativeGoogleSignIn() async {
  //   const webClientId =
  //       '653279524622-tcbl98f4inl6hv8c4ssakc4tofeu7mor.apps.googleusercontent.com';
  //   const iosClientId =
  //       '653279524622-f715bn4fm2md061pvl8qlrcfvftt5rs2.apps.googleusercontent.com';
  //   final GoogleSignIn googleSignIn = GoogleSignIn(
  //     clientId: iosClientId,
  //     serverClientId: webClientId,
  //   );
  //   final googleUser = await googleSignIn.signIn();
  //   final googleAuth = await googleUser!.authentication;
  //   final accessToken = googleAuth.accessToken;
  //   final idToken = googleAuth.idToken;
  //   if (accessToken == null) {
  //     throw 'No Access Token found.';
  //   }
  //   if (idToken == null) {
  //     throw 'No ID Token found.';
  //   }
  //   await supabaseClient.auth.signInWithIdToken(
  //     provider: OAuthProvider.google,
  //     idToken: idToken,
  //     accessToken: accessToken,
  //   );
  // }

  Future<void> signUp(
    String email,
    String password, {
    Map<String, dynamic>? data,
  }) async {
    try {
      await supabaseClient.auth.signUp(
        password: password,
        email: email,
        data: data,
        emailRedirectTo:
            kIsWeb
                ? Constants.supabaseLoginCallbackUrlWeb
                : Constants.supabaseLoginCallbackUrlMobile,
      );
      // The stream will automatically update from onAuthStateChange
    } catch (e) {
      debugPrint('Error signing up: $e');
      rethrow;
    }
  }

  Future<void> signOut() async {
    try {
      await supabaseClient.auth.signOut();
      // The stream will automatically update from onAuthStateChange
    } catch (e) {
      debugPrint('Error signing out: $e');
      rethrow;
    }
  }

  Future<void> recoverPassword(String email) async {
    try {
      final redirectUrl =
          kIsWeb
              ? Constants.supabaseLoginCallbackUrlWeb
              : Constants
                  .supabaseLoginCallbackUrlMobile; // Ensure this deep link is handled
      await supabaseClient.auth.resetPasswordForEmail(
        email,
        redirectTo: redirectUrl,
      );
    } catch (e) {
      debugPrint('Error recovering password: $e');
      rethrow;
    }
  }

  Future<void> updatePassword(String newPassword) async {
    try {
      await supabaseClient.auth.updateUser(
        UserAttributes(password: newPassword),
      );
    } on AuthException catch (e) {
      debugPrint('Error updating password: ${e.message}');
      rethrow;
    }
  }
}

// Example of how the generated provider might look (for conceptual understanding):
// final appAuthProvider = StreamProvider.autoDispose<User?>((ref) {
//   final appAuth = ref.watch(appAuthProvider.notifier);
//   return appAuth.build();
// });
// However, with @Riverpod, it will be `appAuthProvider` for the notifier and `appAuthProvider.stream` or similar.
// The actual provider will be `appAuthProvider`. We will watch `appAuthProvider` to get the `AsyncValue<User?>`.
