import 'dart:async';

import 'package:athena/core/constants/constants.dart';
import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

part 'auth_provider.g.dart'; // This will be generated by build_runner

// Renaming to AppAuth to avoid potential conflicts and make it specific to the app
@Riverpod(keepAlive: true)
class AppAuth extends _$AppAuth {
  late final StreamController<User?> _authStateController;
  StreamSubscription<AuthState>? _authSubscription;

  @override
  Stream<User?> build() {
    _authStateController = StreamController<User?>.broadcast();

    // Initialize with current user state
    _authStateController.add(supabaseClient.auth.currentUser);

    // Listen to Supabase auth state changes
    _authSubscription = supabaseClient.auth.onAuthStateChange.listen((data) {
      _authStateController.add(data.session?.user);
    });

    ref.onDispose(() {
      _authSubscription?.cancel();
      _authStateController.close();
    });

    return _authStateController.stream;
  }

  SupabaseClient get supabaseClient => Supabase.instance.client;
  User? get currentUser => supabaseClient.auth.currentUser;

  // Expose the auth state stream for GoRouter
  Stream<User?> get authStateChanges => _authStateController.stream;

  Future<void> signInWithPassword(String email, String password) async {
    try {
      await supabaseClient.auth.signInWithPassword(
        password: password,
        email: email,
      );
      // The stream will automatically update from onAuthStateChange
    } catch (e) {
      debugPrint('Error signing in: $e');
      rethrow;
    }
  }

  Future<void> signInWithOtp(String email) async {
    try {
      await supabaseClient.auth.signInWithOtp(
        email: email,
        emailRedirectTo:
            kIsWeb
                ? 'https://www.helloathena.app/auth/callback'
                : Constants.supabaseLoginCallbackUrlMobile,
      );
      // Note: This doesn't immediately update the auth state
      // The user will need to click the magic link sent to their email
    } catch (e) {
      debugPrint('Error signing in with OTP: $e');
      rethrow;
    }
  }

  Future<void> signUp(
    String email,
    String password, {
    Map<String, dynamic>? data,
  }) async {
    try {
      await supabaseClient.auth.signUp(
        password: password,
        email: email,
        data: data,
        emailRedirectTo:
            kIsWeb
                ? Constants.supabaseLoginCallbackUrlWeb
                : Constants.supabaseLoginCallbackUrlMobile,
      );
      // The stream will automatically update from onAuthStateChange
    } catch (e) {
      debugPrint('Error signing up: $e');
      rethrow;
    }
  }

  Future<void> signOut() async {
    try {
      await supabaseClient.auth.signOut();
      // The stream will automatically update from onAuthStateChange
    } catch (e) {
      debugPrint('Error signing out: $e');
      rethrow;
    }
  }

  Future<void> recoverPassword(String email) async {
    try {
      final redirectUrl =
          kIsWeb
              ? Constants.supabaseLoginCallbackUrlWeb
              : Constants
                  .supabaseLoginCallbackUrlMobile; // Ensure this deep link is handled
      await supabaseClient.auth.resetPasswordForEmail(
        email,
        redirectTo: redirectUrl,
      );
    } catch (e) {
      debugPrint('Error recovering password: $e');
      rethrow;
    }
  }

  Future<void> updatePassword(String newPassword) async {
    try {
      await supabaseClient.auth.updateUser(
        UserAttributes(password: newPassword),
      );
    } on AuthException catch (e) {
      debugPrint('Error updating password: ${e.message}');
      rethrow;
    }
  }
}

// Example of how the generated provider might look (for conceptual understanding):
// final appAuthProvider = StreamProvider.autoDispose<User?>((ref) {
//   final appAuth = ref.watch(appAuthProvider.notifier);
//   return appAuth.build();
// });
// However, with @Riverpod, it will be `appAuthProvider` for the notifier and `appAuthProvider.stream` or similar.
// The actual provider will be `appAuthProvider`. We will watch `appAuthProvider` to get the `AsyncValue<User?>`.
