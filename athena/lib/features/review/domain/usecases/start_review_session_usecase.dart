import 'package:athena/core/errors/failures.dart';
import 'package:athena/features/review/domain/entities/review_session_entity.dart';
import 'package:athena/features/review/domain/entities/quiz_item_entity.dart';
import 'package:athena/features/review/domain/repositories/review_repository.dart';
import 'package:athena/features/review/domain/usecases/get_due_items_usecase.dart';
import 'package:dartz/dartz.dart';

/// Use case to start a new review session for a quiz.
///
/// This use case creates a review session, determines which items to include,
/// and sets up the session parameters for the review flow.
class StartReviewSessionUseCase {
  final ReviewRepository _repository;
  final GetDueItemsUseCase _getDueItemsUseCase;

  StartReviewSessionUseCase(this._repository, this._getDueItemsUseCase);

  /// Starts a new review session for the specified quiz.
  ///
  /// [params] - Parameters for starting the review session
  ///
  /// Returns Either<Failure, StartReviewSessionResult> with session data or failure
  Future<Either<Failure, StartReviewSessionResult>> call(
    StartReviewSessionParams params,
  ) async {
    try {
      // First, get items for the review session based on session type
      final itemsResult = await _getItemsForSession(params);

      if (itemsResult.isLeft()) {
        return itemsResult.fold(
          (failure) => Left(failure),
          (_) => Left(ServerFailure('Unexpected error getting items')),
        );
      }

      final items = itemsResult.fold(
        (_) => <QuizItemEntity>[],
        (items) => items,
      );

      if (items.isEmpty) {
        return Left(ServerFailure('No items available for review session'));
      }

      // Create the review session entity
      final session = ReviewSessionEntity(
        id: '', // Will be generated by the database
        userId: params.userId,
        quizId: params.quizId,
        sessionType: params.sessionType,
        totalItems: items.length,
        completedItems: 0,
        correctResponses: 0,
        averageDifficulty: null,
        sessionDurationSeconds: null,
        status: SessionStatus.active,
        startedAt: DateTime.now(),
        completedAt: null,
      );

      // Save the session to the database
      final sessionResult = await _repository.createReviewSession(session);

      return sessionResult.fold(
        (failure) => Left(failure),
        (createdSession) => Right(
          StartReviewSessionResult(session: createdSession, items: items),
        ),
      );
    } catch (e) {
      return Left(
        ServerFailure('Failed to start review session: ${e.toString()}'),
      );
    }
  }

  /// Gets the items to include in the review session based on session type.
  Future<Either<Failure, List<QuizItemEntity>>> _getItemsForSession(
    StartReviewSessionParams params,
  ) async {
    switch (params.sessionType) {
      case SessionType.dueOnly:
        // Only items that are due for review
        return await _getDueItemsUseCase.call(
          params.quizId,
          params.userId,
          includeNew: false,
          limit: params.maxItems,
        );

      case SessionType.newOnly:
        // Only new items (never reviewed)
        final allItemsResult = await _repository.getAllQuizItems(params.quizId);
        return allItemsResult.fold((failure) => Left(failure), (allItems) {
          final newItems =
              allItems
                  .where(
                    (item) =>
                        item.userId == params.userId &&
                        item.repetitions == 0 &&
                        item.lastReviewedAt == item.createdAt,
                  )
                  .toList();

          // Apply limit if specified
          if (params.maxItems != null && params.maxItems! > 0) {
            return Right(newItems.take(params.maxItems!).toList());
          }

          return Right(newItems);
        });

      case SessionType.mixed:
        // Both due items and new items
        return await _getDueItemsUseCase.call(
          params.quizId,
          params.userId,
          includeNew: true,
          limit: params.maxItems,
        );
    }
  }
}

/// Parameters for starting a review session.
class StartReviewSessionParams {
  /// ID of the quiz to review
  final String quizId;

  /// ID of the user starting the session
  final String userId;

  /// Type of session (mixed, dueOnly, newOnly)
  final SessionType sessionType;

  /// Maximum number of items to include in the session
  final int? maxItems;

  const StartReviewSessionParams({
    required this.quizId,
    required this.userId,
    required this.sessionType,
    this.maxItems,
  });
}

/// Result of starting a review session.
class StartReviewSessionResult {
  /// The created review session
  final ReviewSessionEntity session;

  /// The items to be reviewed in this session
  final List<QuizItemEntity> items;

  const StartReviewSessionResult({required this.session, required this.items});
}
