import 'package:athena/core/errors/failures.dart';
import 'package:athena/features/review/domain/entities/quiz_item_entity.dart';
import 'package:athena/features/review/domain/entities/review_response_entity.dart';
import 'package:athena/features/review/domain/entities/review_session_entity.dart';
import 'package:athena/features/review/domain/repositories/review_repository.dart';
import 'package:athena/features/review/domain/services/spaced_repetition_service.dart';
import 'package:dartz/dartz.dart';

/// Use case to submit a user's response to a quiz item during a review session.
///
/// This use case handles the core review logic:
/// 1. Records the user's response
/// 2. Calculates new spaced repetition parameters using SM-2 algorithm
/// 3. Updates the quiz item with new review data
/// 4. Updates the review session progress
class SubmitReviewResponseUseCase {
  final ReviewRepository _repository;
  final SpacedRepetitionService _spacedRepetitionService;

  SubmitReviewResponseUseCase(this._repository, this._spacedRepetitionService);

  /// Submits a user's response to a quiz item and updates spaced repetition data.
  ///
  /// [params] - Parameters containing the user's response and context
  ///
  /// Returns Either<Failure, SubmitReviewResponseResult> with updated data or failure
  Future<Either<Failure, SubmitReviewResponseResult>> call(
    SubmitReviewResponseParams params,
  ) async {
    try {
      // Get the current quiz item to access spaced repetition data
      final itemResult = await _repository.getQuizItemById(params.quizItemId);

      if (itemResult.isLeft()) {
        return itemResult.fold(
          (failure) => Left(failure),
          (_) => Left(ServerFailure('Unexpected error getting quiz item')),
        );
      }

      final currentItem = itemResult.fold((_) => null, (item) => item)!;

      // Verify the item belongs to the user
      if (currentItem.userId != params.userId) {
        return Left(ServerFailure('Unauthorized access to quiz item'));
      }

      // Calculate new spaced repetition parameters using SM-2 algorithm
      final spacedRepetitionResult = _spacedRepetitionService
          .calculateNextReview(
            currentItem: currentItem,
            difficultyRating: params.difficultyRating,
            responseTime: params.responseTimeSeconds,
            isCorrect: params.isCorrect,
          );

      // Create the review response entity
      final reviewResponse = ReviewResponseEntity(
        id: '', // Will be generated by the database
        reviewSessionId: params.sessionId,
        quizItemId: params.quizItemId,
        userId: params.userId,
        difficultyRating: params.difficultyRating,
        responseTimeSeconds: params.responseTimeSeconds,
        userAnswer: params.userAnswer,
        isCorrect: params.isCorrect,
        previousEasinessFactor: spacedRepetitionResult.previousEasinessFactor,
        previousIntervalDays: spacedRepetitionResult.previousIntervalDays,
        previousRepetitions: spacedRepetitionResult.previousRepetitions,
        newEasinessFactor: spacedRepetitionResult.newEasinessFactor,
        newIntervalDays: spacedRepetitionResult.newIntervalDays,
        newRepetitions: spacedRepetitionResult.newRepetitions,
        newNextReviewDate: spacedRepetitionResult.nextReviewDate,
        respondedAt: DateTime.now(),
      );

      // Save the review response
      final responseResult = await _repository.createReviewResponse(
        reviewResponse,
      );

      if (responseResult.isLeft()) {
        return responseResult.fold(
          (failure) => Left(failure),
          (_) => Left(ServerFailure('Unexpected error saving review response')),
        );
      }

      final savedResponse =
          responseResult.fold((_) => null, (response) => response)!;

      // Update the quiz item with new spaced repetition data
      final updatedItem = currentItem.copyWith(
        easinessFactor: spacedRepetitionResult.newEasinessFactor,
        intervalDays: spacedRepetitionResult.newIntervalDays,
        repetitions: spacedRepetitionResult.newRepetitions,
        lastReviewedAt: DateTime.now(),
        nextReviewDate: spacedRepetitionResult.nextReviewDate,
        updatedAt: DateTime.now(),
      );

      final updateItemResult = await _repository.updateQuizItem(updatedItem);

      if (updateItemResult.isLeft()) {
        return updateItemResult.fold(
          (failure) => Left(failure),
          (_) => Left(ServerFailure('Unexpected error updating quiz item')),
        );
      }

      final finalUpdatedItem =
          updateItemResult.fold((_) => null, (item) => item)!;

      // Update session progress if needed
      if (params.updateSessionProgress) {
        final sessionUpdateResult = await _updateSessionProgress(
          params.sessionId,
          params.difficultyRating,
          params.isCorrect,
        );

        if (sessionUpdateResult.isLeft()) {
          // Log the error but don't fail the entire operation
          // The response and item update were successful
          print(
            'Warning: Failed to update session progress: ${sessionUpdateResult.fold((l) => l.message, (_) => 'Unknown error')}',
          );
        }
      }

      return Right(
        SubmitReviewResponseResult(
          reviewResponse: savedResponse,
          updatedQuizItem: finalUpdatedItem,
          spacedRepetitionResult: spacedRepetitionResult,
        ),
      );
    } catch (e) {
      return Left(
        ServerFailure('Failed to submit review response: ${e.toString()}'),
      );
    }
  }

  /// Updates the review session progress with the new response.
  Future<Either<Failure, ReviewSessionEntity>> _updateSessionProgress(
    String sessionId,
    DifficultyRating difficultyRating,
    bool? isCorrect,
  ) async {
    try {
      // Get the current session
      final sessionResult = await _repository.getReviewSessionById(sessionId);

      if (sessionResult.isLeft()) {
        return sessionResult.fold(
          (failure) => Left(failure),
          (_) => Left(ServerFailure('Unexpected error getting session')),
        );
      }

      final currentSession =
          sessionResult.fold((_) => null, (session) => session)!;

      // Calculate new progress metrics
      final newCompletedItems = currentSession.completedItems + 1;
      final newCorrectResponses =
          currentSession.correctResponses + (isCorrect == true ? 1 : 0);

      // Calculate average difficulty (1-4 scale where 1=again, 4=easy)
      final difficultyValue = difficultyRating.index + 1; // Convert 0-3 to 1-4
      final currentTotal = currentSession.averageDifficulty ?? 0.0;
      final currentCount = currentSession.completedItems;
      final newAverageDifficulty =
          currentCount == 0
              ? difficultyValue.toDouble()
              : ((currentTotal * currentCount) + difficultyValue) /
                  newCompletedItems;

      // Check if session is completed
      final isCompleted = newCompletedItems >= currentSession.totalItems;
      final sessionStatus =
          isCompleted ? SessionStatus.completed : SessionStatus.active;
      final completedAt = isCompleted ? DateTime.now() : null;

      // Calculate session duration if completed
      int? sessionDuration;
      if (isCompleted) {
        final duration = DateTime.now().difference(currentSession.startedAt);
        sessionDuration = duration.inSeconds;
      }

      // Update the session
      final updatedSession = currentSession.copyWith(
        completedItems: newCompletedItems,
        correctResponses: newCorrectResponses,
        averageDifficulty: newAverageDifficulty,
        sessionDurationSeconds:
            sessionDuration ?? currentSession.sessionDurationSeconds,
        status: sessionStatus,
        completedAt: completedAt,
      );

      return await _repository.updateReviewSession(updatedSession);
    } catch (e) {
      return Left(
        ServerFailure('Failed to update session progress: ${e.toString()}'),
      );
    }
  }
}

/// Parameters for submitting a review response.
class SubmitReviewResponseParams {
  /// ID of the review session
  final String sessionId;

  /// ID of the quiz item being reviewed
  final String quizItemId;

  /// ID of the user submitting the response
  final String userId;

  /// User's self-assessment of difficulty
  final DifficultyRating difficultyRating;

  /// Time taken to respond in seconds
  final int? responseTimeSeconds;

  /// User's answer (for MCQ: selected option key, for flashcards: can be null)
  final String? userAnswer;

  /// Whether the answer was correct (for MCQ: automatic, for flashcards: based on self-assessment)
  final bool? isCorrect;

  /// Whether to update session progress (defaults to true)
  final bool updateSessionProgress;

  const SubmitReviewResponseParams({
    required this.sessionId,
    required this.quizItemId,
    required this.userId,
    required this.difficultyRating,
    this.responseTimeSeconds,
    this.userAnswer,
    this.isCorrect,
    this.updateSessionProgress = true,
  });
}

/// Result of submitting a review response.
class SubmitReviewResponseResult {
  /// The saved review response
  final ReviewResponseEntity reviewResponse;

  /// The updated quiz item with new spaced repetition data
  final QuizItemEntity updatedQuizItem;

  /// The spaced repetition calculation result
  final SpacedRepetitionResult spacedRepetitionResult;

  const SubmitReviewResponseResult({
    required this.reviewResponse,
    required this.updatedQuizItem,
    required this.spacedRepetitionResult,
  });
}
