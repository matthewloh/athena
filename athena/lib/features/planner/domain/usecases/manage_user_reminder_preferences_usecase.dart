import 'package:athena/core/errors/failures.dart';
import 'package:athena/features/planner/domain/entities/user_reminder_preferences_entity.dart';
import 'package:athena/features/planner/domain/repositories/reminder_repository.dart';
import 'package:dartz/dartz.dart';

/// Use case for managing user reminder preferences
class ManageUserReminderPreferencesUseCase {
  final ReminderRepository _repository;

  const ManageUserReminderPreferencesUseCase(this._repository);

  /// Gets user reminder preferences
  Future<Either<Failure, UserReminderPreferencesEntity>> getUserPreferences(
    String userId,
  ) {
    return _repository.getUserReminderPreferences(userId);
  }

  /// Creates new user reminder preferences with defaults
  Future<Either<Failure, UserReminderPreferencesEntity>> createUserPreferences(
    String userId,
  ) {
    final preferences = UserReminderPreferencesEntity(
      id: '', // Will be generated by backend
      userId: userId,
      sessionRemindersEnabled: true,
      goalRemindersEnabled: true,
      dailyCheckinsEnabled: false,
      streakRemindersEnabled: true,
      quietHoursStart: '22:00',
      quietHoursEnd: '06:00',
      timezone: 'Asia/Kuala_Lumpur',
      defaultReminderTemplateIds: [],
      notificationsEnabled: true,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
    );

    return _repository.createUserReminderPreferences(preferences);
  }

  /// Updates user reminder preferences
  Future<Either<Failure, UserReminderPreferencesEntity>> updateUserPreferences(
    UserReminderPreferencesEntity preferences,
  ) {
    return _repository.updateUserReminderPreferences(preferences);
  }

  /// Toggles a specific reminder type
  Future<Either<Failure, UserReminderPreferencesEntity>> toggleReminderType(
    String userId,
    ReminderType reminderType,
    bool enabled,
  ) async {
    final preferencesResult = await getUserPreferences(userId);

    return preferencesResult.fold((failure) => Left(failure), (
      preferences,
    ) async {
      final updatedPreferences = preferences.copyWith(
        sessionRemindersEnabled:
            reminderType == ReminderType.session
                ? enabled
                : preferences.sessionRemindersEnabled,
        goalRemindersEnabled:
            reminderType == ReminderType.goal
                ? enabled
                : preferences.goalRemindersEnabled,
        dailyCheckinsEnabled:
            reminderType == ReminderType.daily
                ? enabled
                : preferences.dailyCheckinsEnabled,
        streakRemindersEnabled:
            reminderType == ReminderType.streak
                ? enabled
                : preferences.streakRemindersEnabled,
      );

      return await updateUserPreferences(updatedPreferences);
    });
  }

  /// Updates quiet hours settings
  Future<Either<Failure, UserReminderPreferencesEntity>> updateQuietHours(
    String userId,
    String startTime,
    String endTime,
  ) async {
    final preferencesResult = await getUserPreferences(userId);

    return preferencesResult.fold((failure) => Left(failure), (
      preferences,
    ) async {
      final updatedPreferences = preferences.copyWith(
        quietHoursStart: startTime,
        quietHoursEnd: endTime,
      );

      return await updateUserPreferences(updatedPreferences);
    });
  }

  /// Updates default reminder offset
  Future<Either<Failure, UserReminderPreferencesEntity>>
  updateDefaultReminderOffset(String userId, int offsetMinutes) async {
    final preferencesResult = await getUserPreferences(userId);

    return preferencesResult.fold((failure) => Left(failure), (
      preferences,
    ) async {
      final updatedPreferences = preferences.copyWith(
        defaultReminderTemplateIds: [offsetMinutes.toString()],
      );

      return await updateUserPreferences(updatedPreferences);
    });
  }
}

/// Enum for reminder types to make toggling easier
enum ReminderType { session, goal, daily, streak }
