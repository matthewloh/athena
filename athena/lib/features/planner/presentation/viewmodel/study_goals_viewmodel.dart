import 'package:athena/features/planner/domain/entities/study_goal_entity.dart';
import 'package:athena/features/planner/domain/repositories/planner_repository.dart';
import 'package:athena/features/planner/presentation/providers/planner_providers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'study_goals_viewmodel.g.dart';

/// State class for study goals
class StudyGoalsState {
  final List<StudyGoalEntity> goals;
  final bool isLoading;
  final String? errorMessage;
  final StudyGoalEntity? selectedGoal;

  const StudyGoalsState({
    this.goals = const [],
    this.isLoading = false,
    this.errorMessage,
    this.selectedGoal,
  });

  StudyGoalsState copyWith({
    List<StudyGoalEntity>? goals,
    bool? isLoading,
    String? errorMessage,
    StudyGoalEntity? selectedGoal,
    bool clearError = false,
    bool clearSelectedGoal = false,
  }) {
    return StudyGoalsState(
      goals: goals ?? this.goals,
      isLoading: isLoading ?? this.isLoading,
      errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
      selectedGoal:
          clearSelectedGoal ? null : (selectedGoal ?? this.selectedGoal),
    );
  }

  // Computed properties for UI
  List<StudyGoalEntity> get activeGoals =>
      goals.where((goal) => !goal.isCompleted).toList();
  List<StudyGoalEntity> get completedGoals =>
      goals.where((goal) => goal.isCompleted).toList();
  List<StudyGoalEntity> get overdueGoals =>
      goals.where((goal) => goal.isOverdue).toList();
  int get totalGoals => goals.length;
  int get completedCount => completedGoals.length;
  double get overallProgress =>
      totalGoals > 0 ? completedCount / totalGoals : 0.0;
}

/// ViewModel for managing study goals
@riverpod
class StudyGoalsViewModel extends _$StudyGoalsViewModel {
  late PlannerRepository _repository;
  String? _currentUserId;

  @override
  StudyGoalsState build() {
    _repository = ref.watch(plannerRepositoryProvider);
    _currentUserId = ref.watch(currentUserIdProvider);

    // Auto-load goals when ViewModel is created
    if (_currentUserId != null) {
      Future.microtask(() => _loadGoals());
    }

    return const StudyGoalsState();
  }

  // ============================================================================
  // PUBLIC METHODS
  // ============================================================================

  /// Loads all study goals for the current user
  Future<void> loadGoals() async {
    await _loadGoals();
  }

  /// Refreshes the goals list
  Future<void> refreshGoals() async {
    await _loadGoals(forceRefresh: true);
  }

  /// Creates a new study goal
  Future<bool> createGoal({
    required String title,
    String? description,
    String? subject,
    DateTime? targetDate,
  }) async {
    if (_currentUserId == null) {
      _setError('User not authenticated');
      return false;
    }

    state = state.copyWith(isLoading: true, clearError: true);

    try {
      final newGoal = StudyGoalEntity(
        id: '', // Will be generated by database
        userId: _currentUserId!,
        title: title,
        description: description,
        subject: subject,
        targetDate: targetDate,
        progress: 0.0,
        isCompleted: false,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final result = await _repository.createStudyGoal(newGoal);

      return result.fold(
        (failure) {
          _setError('Failed to create goal: ${failure.message}');
          return false;
        },
        (createdGoal) {
          // Add the new goal to the current state
          final updatedGoals = [...state.goals, createdGoal];
          state = state.copyWith(
            goals: updatedGoals,
            isLoading: false,
            clearError: true,
          );
          return true;
        },
      );
    } catch (e) {
      _setError('Unexpected error: $e');
      return false;
    }
  }

  /// Updates an existing study goal
  Future<bool> updateGoal(StudyGoalEntity goal) async {
    state = state.copyWith(isLoading: true, clearError: true);

    try {
      final result = await _repository.updateStudyGoal(goal);

      return result.fold(
        (failure) {
          _setError('Failed to update goal: ${failure.message}');
          return false;
        },
        (updatedGoal) {
          // Update the goal in the current state
          final updatedGoals =
              state.goals.map((g) {
                return g.id == updatedGoal.id ? updatedGoal : g;
              }).toList();

          state = state.copyWith(
            goals: updatedGoals,
            isLoading: false,
            clearError: true,
          );
          return true;
        },
      );
    } catch (e) {
      _setError('Unexpected error: $e');
      return false;
    }
  }

  /// Updates the progress of a specific goal
  Future<bool> updateGoalProgress(String goalId, double progress) async {
    if (_currentUserId == null) return false;

    try {
      final result = await _repository.updateGoalProgress(goalId, progress);

      return result.fold(
        (failure) {
          _setError('Failed to update progress: ${failure.message}');
          return false;
        },
        (updatedGoal) {
          // Update the goal in the current state
          final updatedGoals =
              state.goals.map((g) {
                return g.id == updatedGoal.id ? updatedGoal : g;
              }).toList();

          state = state.copyWith(goals: updatedGoals, clearError: true);
          return true;
        },
      );
    } catch (e) {
      _setError('Failed to update progress: $e');
      return false;
    }
  }

  /// Marks a goal as completed
  Future<bool> markGoalCompleted(String goalId) async {
    if (_currentUserId == null) return false;

    try {
      final result = await _repository.markGoalCompleted(goalId);

      return result.fold(
        (failure) {
          _setError('Failed to complete goal: ${failure.message}');
          return false;
        },
        (completedGoal) {
          // Update the goal in the current state
          final updatedGoals =
              state.goals.map((g) {
                return g.id == completedGoal.id ? completedGoal : g;
              }).toList();

          state = state.copyWith(goals: updatedGoals, clearError: true);
          return true;
        },
      );
    } catch (e) {
      _setError('Failed to complete goal: $e');
      return false;
    }
  }

  /// Deletes a study goal
  Future<bool> deleteGoal(String goalId) async {
    state = state.copyWith(isLoading: true, clearError: true);

    try {
      final result = await _repository.deleteStudyGoal(goalId);

      return result.fold(
        (failure) {
          _setError('Failed to delete goal: ${failure.message}');
          return false;
        },
        (_) {
          // Remove the goal from the current state
          final updatedGoals =
              state.goals.where((g) => g.id != goalId).toList();
          state = state.copyWith(
            goals: updatedGoals,
            isLoading: false,
            clearError: true,
          );
          return true;
        },
      );
    } catch (e) {
      _setError('Unexpected error: $e');
      return false;
    }
  }

  /// Selects a goal for detailed view
  void selectGoal(StudyGoalEntity goal) {
    state = state.copyWith(selectedGoal: goal);
  }

  /// Clears the selected goal
  void clearSelectedGoal() {
    state = state.copyWith(clearSelectedGoal: true);
  }

  /// Clears any error messages
  void clearError() {
    state = state.copyWith(clearError: true);
  }

  // ============================================================================
  // PRIVATE METHODS
  // ============================================================================

  Future<void> _loadGoals({bool forceRefresh = false}) async {
    print(
      '_loadGoals called - User ID: $_currentUserId, forceRefresh: $forceRefresh',
    );

    if (_currentUserId == null) {
      final errorMsg = 'User not authenticated';
      print('_loadGoals error: $errorMsg');
      _setError(errorMsg);
      return;
    }

    // Only show loading on initial load or force refresh
    if (state.goals.isEmpty || forceRefresh) {
      state = state.copyWith(isLoading: true, clearError: true);
      print('_loadGoals - Set loading state');
    }

    try {
      print(
        '_loadGoals - Calling repository.getStudyGoals with userId: $_currentUserId',
      );
      final result = await _repository.getStudyGoals(_currentUserId!);

      result.fold(
        (failure) {
          final errorMsg = 'Failed to load goals: ${failure.message}';
          print('_loadGoals failure: $errorMsg');
          _setError(errorMsg);
        },
        (goals) {
          print('_loadGoals success - Loaded ${goals.length} goals');
          for (var goal in goals) {
            print('  Goal: ${goal.title} (ID: ${goal.id})');
          }
          state = state.copyWith(
            goals: goals,
            isLoading: false,
            clearError: true,
          );
        },
      );
    } catch (e) {
      final errorMsg = 'Unexpected error: $e';
      print('_loadGoals exception: $errorMsg');
      _setError(errorMsg);
    }
  }

  void _setError(String message) {
    state = state.copyWith(errorMessage: message, isLoading: false);
  }
}

// ============================================================================
// COMPUTED PROVIDERS
// ============================================================================

/// Provider for active goals (not completed)
@riverpod
List<StudyGoalEntity> activeStudyGoals(Ref ref) {
  return ref.watch(studyGoalsViewModelProvider).activeGoals;
}

/// Provider for completed goals
@riverpod
List<StudyGoalEntity> completedStudyGoals(Ref ref) {
  return ref.watch(studyGoalsViewModelProvider).completedGoals;
}

/// Provider for overdue goals
@riverpod
List<StudyGoalEntity> overdueStudyGoals(Ref ref) {
  return ref.watch(studyGoalsViewModelProvider).overdueGoals;
}
